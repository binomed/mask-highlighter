{"version":3,"file":"lit-html.js","sourceRoot":"","sources":["src/lit-html.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * TypeScript has a problem with precompiling templates literals\n * https://github.com/Microsoft/TypeScript/issues/17956\n *\n * TODO(justinfagnani): Run tests compiled to ES5 with both Babel and\n * TypeScript to verify correctness.\n */\nconst envCachesTemplates =\n    ((t: any) => t() === t())(() => ((s: TemplateStringsArray) => s) ``);\n\n// The first argument to JS template tags retain identity across multiple\n// calls to a tag for the same literal, so we can cache work done per literal\n// in a Map.\nconst templates = new Map<TemplateStringsArray|string, Template>();\nconst svgTemplates = new Map<TemplateStringsArray|string, Template>();\n\n/**\n * Interprets a template literal as an HTML template that can efficiently\n * render to and update a container.\n */\nexport const html = (strings: TemplateStringsArray, ...values: any[]) =>\n    litTag(strings, values, templates, false);\n\n/**\n * Interprets a template literal as an SVG template that can efficiently\n * render to and update a container.\n */\nexport const svg = (strings: TemplateStringsArray, ...values: any[]) =>\n    litTag(strings, values, svgTemplates, true);\n\nfunction litTag(\n    strings: TemplateStringsArray,\n    values: any[],\n    templates: Map<TemplateStringsArray|string, Template>,\n    isSvg: boolean): TemplateResult {\n  const key = envCachesTemplates ?\n      strings :\n      strings.join('{{--uniqueness-workaround--}}');\n  let template = templates.get(key);\n  if (template === undefined) {\n    template = new Template(strings, isSvg);\n    templates.set(key, template);\n  }\n  return new TemplateResult(template, values);\n}\n\n/**\n * The return type of `html`, which holds a Template and the values from\n * interpolated expressions.\n */\nexport class TemplateResult {\n  template: Template;\n  values: any[];\n\n  constructor(template: Template, values: any[]) {\n    this.template = template;\n    this.values = values;\n  }\n}\n\n/**\n * Renders a template to a container.\n *\n * To update a container with new values, reevaluate the template literal and\n * call `render` with the new result.\n */\nexport function render(\n    result: TemplateResult,\n    container: Element|DocumentFragment,\n    partCallback: PartCallback = defaultPartCallback) {\n  let instance = (container as any).__templateInstance as any;\n\n  // Repeat render, just call update()\n  if (instance !== undefined && instance.template === result.template &&\n      instance._partCallback === partCallback) {\n    instance.update(result.values);\n    return;\n  }\n\n  // First render, create a new TemplateInstance and append it\n  instance = new TemplateInstance(result.template, partCallback);\n  (container as any).__templateInstance = instance;\n\n  const fragment = instance._clone();\n  instance.update(result.values);\n\n  let child;\n  while ((child = container.lastChild)) {\n    container.removeChild(child);\n  }\n  container.appendChild(fragment);\n}\n\n/**\n * An expression marker with embedded unique key to avoid\n * https://github.com/PolymerLabs/lit-html/issues/62\n */\nconst attributeMarker = `{{lit-${Math.random()}}}`;\n\n/**\n * Regex to scan the string preceding an expression to see if we're in a text\n * context, and not an attribute context.\n *\n * This works by seeing if we have a `>` not followed by a `<`. If there is a\n * `<` closer to the end of the strings, then we're inside a tag.\n */\nconst textRegex = />[^<]*$/;\nconst hasTagsRegex = /[^<]*/;\nconst textMarkerContent = '_-lit-html-_';\nconst textMarker = `<!--${textMarkerContent}-->`;\nconst attrOrTextRegex = new RegExp(`${attributeMarker}|${textMarker}`);\n\n/**\n * A placeholder for a dynamic expression in an HTML template.\n *\n * There are two built-in part types: AttributePart and NodePart. NodeParts\n * always represent a single dynamic expression, while AttributeParts may\n * represent as many expressions are contained in the attribute.\n *\n * A Template's parts are mutable, so parts can be replaced or modified\n * (possibly to implement different template semantics). The contract is that\n * parts can only be replaced, not removed, added or reordered, and parts must\n * always consume the correct number of values in their `update()` method.\n *\n * TODO(justinfagnani): That requirement is a little fragile. A\n * TemplateInstance could instead be more careful about which values it gives\n * to Part.update().\n */\nexport class TemplatePart {\n  constructor(\n      public type: string, public index: number, public name?: string,\n      public rawName?: string, public strings?: string[]) {\n  }\n}\n\n\nexport class Template {\n  parts: TemplatePart[] = [];\n  element: HTMLTemplateElement;\n  svg: boolean;\n\n  constructor(strings: TemplateStringsArray, svg: boolean = false) {\n    this.svg = svg;\n    this.element = document.createElement('template');\n    this.element.innerHTML = this._getHtml(strings, svg);\n    // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null\n    const walker = document.createTreeWalker(\n        this.element.content,\n        133 /* NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT |\n               NodeFilter.SHOW_TEXT */\n        ,\n        null as any,\n        false);\n    let index = -1;\n    let partIndex = 0;\n    const nodesToRemove: Node[] = [];\n\n    // The actual previous node, accounting for removals: if a node is removed\n    // it will never be the previousNode.\n    let previousNode: Node|undefined;\n    // Used to set previousNode at the top of the loop.\n    let currentNode: Node|undefined;\n\n    while (walker.nextNode()) {\n      index++;\n      previousNode = currentNode;\n      const node = currentNode = walker.currentNode as Element;\n      if (node.nodeType === 1 /* Node.ELEMENT_NODE */) {\n        if (!node.hasAttributes()) {\n          continue;\n        }\n        const attributes = node.attributes;\n        for (let i = 0; i < attributes.length; i++) {\n          const attribute = attributes.item(i);\n          const attributeStrings = attribute.value.split(attrOrTextRegex);\n          if (attributeStrings.length > 1) {\n            // Get the template literal section leading up to the first\n            // expression in this attribute attribute\n            const attributeString = strings[partIndex];\n            // Trim the trailing literal value if this is an interpolation\n            const rawNameString = attributeString.substring(\n                0, attributeString.length - attributeStrings[0].length);\n            // Find the attribute name\n            const rawName = rawNameString.match(/((?:\\w|[.\\-_$])+)=[\"']?$/)![1];\n            this.parts.push(new TemplatePart(\n                'attribute', index, attribute.name, rawName, attributeStrings));\n            node.removeAttribute(attribute.name);\n            partIndex += attributeStrings.length - 1;\n            i--;\n          }\n        }\n      } else if (node.nodeType === 3 /* Node.TEXT_NODE */) {\n        const nodeValue = node.nodeValue!;\n        const strings = nodeValue.split(attributeMarker);\n        if (strings.length > 1) {\n          const parent = node.parentNode!;\n          const lastIndex = strings.length - 1;\n\n          // We have a part for each match found\n          partIndex += lastIndex;\n\n          // We keep this current node, but reset its content to the last\n          // literal part. We insert new literal nodes before this so that the\n          // tree walker keeps its position correctly.\n          node.textContent = strings[lastIndex];\n\n          // Generate a new text node for each literal section\n          // These nodes are also used as the markers for node parts\n          for (let i = 0; i < lastIndex; i++) {\n            parent.insertBefore(document.createTextNode(strings[i]), node);\n            this.parts.push(new TemplatePart('node', index++));\n          }\n        } else {\n          // Strip whitespace-only nodes, only between elements, or at the\n          // beginning or end of elements.\n          const previousSibling = node.previousSibling;\n          const nextSibling = node.nextSibling;\n          if ((previousSibling === null ||\n               previousSibling.nodeType === 1 /* Node.ELEMENT_NODE */) &&\n              (nextSibling === null ||\n               nextSibling.nodeType === 1 /* Node.ELEMENT_NODE */) &&\n              nodeValue.trim() === '') {\n            nodesToRemove.push(node);\n            currentNode = previousNode;\n            index--;\n          }\n        }\n      } else if (\n          node.nodeType === 8 /* Node.COMMENT_NODE */ &&\n          node.nodeValue === textMarkerContent) {\n        const parent = node.parentNode!;\n        // If we don't have a previous node add a marker node.\n        // If the previousSibling is removed, because it's another part\n        // placholder, or empty text, add a marker node.\n        if (node.previousSibling === null ||\n            node.previousSibling !== previousNode) {\n          parent.insertBefore(new Text(), node);\n        } else {\n          index--;\n        }\n        this.parts.push(new TemplatePart('node', index++));\n        nodesToRemove.push(node);\n        // If we don't have a next node add a marker node.\n        // We don't have to check if the next node is going to be removed,\n        // because that node will induce a marker if so.\n        if (node.nextSibling === null) {\n          parent.insertBefore(new Text(), node);\n        } else {\n          index--;\n        }\n        currentNode = previousNode;\n        partIndex++;\n      }\n    }\n\n    // Remove text binding nodes after the walk to not disturb the TreeWalker\n    for (const n of nodesToRemove) {\n      n.parentNode!.removeChild(n);\n    }\n  }\n\n  /**\n   * Returns a string of HTML used to create a <template> element.\n   */\n  private _getHtml(strings: TemplateStringsArray, svg?: boolean): string {\n    const l = strings.length;\n    const a = [];\n    let isTextBinding = false;\n    for (let i = 0; i < l - 1; i++) {\n      const s = strings[i];\n      a.push(s);\n      // We're in a text position if the previous string matches the\n      // textRegex. If it doesn't and the previous string has no tags, then\n      // we use the previous text position state.\n      isTextBinding = s.match(textRegex) !== null ||\n          (s.match(hasTagsRegex) !== null && isTextBinding);\n      a.push(isTextBinding ? textMarker : attributeMarker);\n    }\n    a.push(strings[l - 1]);\n    const html = a.join('');\n    return svg ? `<svg>${html}</svg>` : html;\n  }\n}\n\nexport const getValue = (part: Part, value: any) => {\n  // `null` as the value of a Text node will render the string 'null'\n  // so we convert it to undefined\n  if (value != null && value.__litDirective === true) {\n    value = value(part);\n  }\n  return value === null ? undefined : value;\n};\n\nexport type DirectiveFn = (part: Part) => any;\n\nexport const directive = <F extends DirectiveFn>(f: F): F => {\n  (f as any).__litDirective = true;\n  return f;\n};\n\nexport interface Part {\n  instance: TemplateInstance;\n  size?: number;\n\n  // constructor(instance: TemplateInstance) {\n  //   this.instance = instance;\n  // }\n}\n\nexport interface SinglePart extends Part { setValue(value: any): void; }\n\nexport interface MultiPart extends Part {\n  setValue(values: any[], startIndex: number): void;\n}\n\nexport class AttributePart implements MultiPart {\n  instance: TemplateInstance;\n  element: Element;\n  name: string;\n  strings: string[];\n  size: number;\n\n  constructor(\n      instance: TemplateInstance, element: Element, name: string,\n      strings: string[]) {\n    this.instance = instance;\n    this.element = element;\n    this.name = name;\n    this.strings = strings;\n    this.size = strings.length - 1;\n  }\n\n  setValue(values: any[], startIndex: number): void {\n    const strings = this.strings;\n    let text = '';\n\n    for (let i = 0; i < strings.length; i++) {\n      text += strings[i];\n      if (i < strings.length - 1) {\n        const v = getValue(this, values[startIndex + i]);\n        if (v &&\n            (Array.isArray(v) || typeof v !== 'string' && v[Symbol.iterator])) {\n          for (const t of v) {\n            // TODO: we need to recursively call getValue into iterables...\n            text += t;\n          }\n        } else {\n          text += v;\n        }\n      }\n    }\n    this.element.setAttribute(this.name, text);\n  }\n}\n\nexport class NodePart implements SinglePart {\n  instance: TemplateInstance;\n  startNode: Node;\n  endNode: Node;\n  private _previousValue: any;\n\n  constructor(instance: TemplateInstance, startNode: Node, endNode: Node) {\n    this.instance = instance;\n    this.startNode = startNode;\n    this.endNode = endNode;\n    this._previousValue = undefined;\n  }\n\n  setValue(value: any): void {\n    value = getValue(this, value);\n\n    if (value === null ||\n        !(typeof value === 'object' || typeof value === 'function')) {\n      // Handle primitive values\n      // If the value didn't change, do nothing\n      if (value === this._previousValue) {\n        return;\n      }\n      this._setText(value);\n    } else if (value instanceof TemplateResult) {\n      this._setTemplateResult(value);\n    } else if (Array.isArray(value) || value[Symbol.iterator]) {\n      this._setIterable(value);\n    } else if (value instanceof Node) {\n      this._setNode(value);\n    } else if (value.then !== undefined) {\n      this._setPromise(value);\n    } else {\n      // Fallback, will render the string representation\n      this._setText(value);\n    }\n  }\n\n  private _insert(node: Node) {\n    this.endNode.parentNode!.insertBefore(node, this.endNode);\n  }\n\n  private _setNode(value: Node): void {\n    this.clear();\n    this._insert(value);\n    this._previousValue = value;\n  }\n\n  private _setText(value: string): void {\n    const node = this.startNode.nextSibling!;\n    if (node === this.endNode.previousSibling &&\n        node.nodeType === Node.TEXT_NODE) {\n      // If we only have a single text node between the markers, we can just\n      // set its value, rather than replacing it.\n      // TODO(justinfagnani): Can we just check if _previousValue is\n      // primitive?\n      node.textContent = value;\n    } else {\n      this._setNode(document.createTextNode(value === undefined ? '' : value));\n    }\n    this._previousValue = value;\n  }\n\n  private _setTemplateResult(value: TemplateResult): void {\n    let instance: TemplateInstance;\n    if (this._previousValue &&\n        this._previousValue.template === value.template) {\n      instance = this._previousValue;\n    } else {\n      instance =\n          new TemplateInstance(value.template, this.instance._partCallback);\n      this._setNode(instance._clone());\n      this._previousValue = instance;\n    }\n    instance.update(value.values);\n  }\n\n  private _setIterable(value: any): void {\n    // For an Iterable, we create a new InstancePart per item, then set its\n    // value to the item. This is a little bit of overhead for every item in\n    // an Iterable, but it lets us recurse easily and efficiently update Arrays\n    // of TemplateResults that will be commonly returned from expressions like:\n    // array.map((i) => html`${i}`), by reusing existing TemplateInstances.\n\n    // If _previousValue is an array, then the previous render was of an\n    // iterable and _previousValue will contain the NodeParts from the previous\n    // render. If _previousValue is not an array, clear this part and make a new\n    // array for NodeParts.\n    if (!Array.isArray(this._previousValue)) {\n      this.clear();\n      this._previousValue = [];\n    }\n\n    // Lets us keep track of how many items we stamped so we can clear leftover\n    // items from a previous render\n    const itemParts = this._previousValue as any[];\n    let partIndex = 0;\n\n    for (const item of value) {\n      // Try to reuse an existing part\n      let itemPart = itemParts[partIndex];\n\n      // If no existing part, create a new one\n      if (itemPart === undefined) {\n        // If we're creating the first item part, it's startNode should be the\n        // container's startNode\n        let itemStart = this.startNode;\n\n        // If we're not creating the first part, create a new separator marker\n        // node, and fix up the previous part's endNode to point to it\n        if (partIndex > 0) {\n          const previousPart = itemParts[partIndex - 1];\n          itemStart = previousPart.endNode = document.createTextNode('');\n          this._insert(itemStart);\n        }\n        itemPart = new NodePart(this.instance, itemStart, this.endNode);\n        itemParts.push(itemPart);\n      }\n      itemPart.setValue(item);\n      partIndex++;\n    }\n\n    if (partIndex === 0) {\n      this.clear();\n      this._previousValue = undefined;\n    } else if (partIndex < itemParts.length) {\n      const lastPart = itemParts[partIndex - 1];\n      // Truncate the parts array so _previousValue reflects the current state\n      itemParts.length = partIndex;\n      this.clear(lastPart.endNode.previousSibling!);\n      lastPart.endNode = this.endNode;\n    }\n  }\n\n  protected _setPromise(value: Promise<any>): void {\n    value.then((v: any) => {\n      if (this._previousValue === value) {\n        this.setValue(v);\n      }\n    });\n    this._previousValue = value;\n  }\n\n  clear(startNode: Node = this.startNode) {\n    let node;\n    while ((node = startNode.nextSibling!) !== this.endNode) {\n      node.parentNode!.removeChild(node);\n    }\n  }\n}\n\nexport type PartCallback =\n    (instance: TemplateInstance, templatePart: TemplatePart, node: Node) =>\n        Part;\n\nexport const defaultPartCallback =\n    (instance: TemplateInstance,\n     templatePart: TemplatePart,\n     node: Node): Part => {\n      if (templatePart.type === 'attribute') {\n        return new AttributePart(\n            instance, node as Element, templatePart.name!, templatePart.strings!\n        );\n      } else if (templatePart.type === 'node') {\n        return new NodePart(instance, node, node.nextSibling!);\n      }\n      throw new Error(`Unknown part type ${templatePart.type}`);\n    };\n\n/**\n * An instance of a `Template` that can be attached to the DOM and updated\n * with new values.\n */\nexport class TemplateInstance {\n  _parts: Part[] = [];\n  _partCallback: PartCallback;\n  template: Template;\n\n  constructor(\n      template: Template, partCallback: PartCallback = defaultPartCallback) {\n    this.template = template;\n    this._partCallback = partCallback;\n  }\n\n  update(values: any[]) {\n    let valueIndex = 0;\n    for (const part of this._parts) {\n      if (part.size === undefined) {\n        (part as SinglePart).setValue(values[valueIndex]);\n        valueIndex++;\n      } else {\n        (part as MultiPart).setValue(values, valueIndex);\n        valueIndex += part.size;\n      }\n    }\n  }\n\n  _clone(): DocumentFragment {\n    const fragment = document.importNode(this.template.element.content, true);\n\n    if (this.template.parts.length > 0) {\n      // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be\n      // null\n      const walker = document.createTreeWalker(\n          fragment,\n          133 /* NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT */\n          ,\n          null as any,\n          false);\n\n      const parts = this.template.parts;\n      let index = 0;\n      let partIndex = 0;\n      let templatePart = parts[0];\n      let node = walker.nextNode();\n      while (node != null && partIndex < parts.length) {\n        if (index === templatePart.index) {\n          this._parts.push(this._partCallback(this, templatePart, node));\n          templatePart = parts[++partIndex];\n        } else {\n          index++;\n          node = walker.nextNode();\n        }\n      }\n    }\n    if (this.template.svg) {\n      const svgElement = fragment.firstChild!;\n      fragment.removeChild(svgElement);\n      const nodes = svgElement.childNodes;\n      for (let i = 0; i < nodes.length; i++) {\n        fragment.appendChild(nodes.item(i));\n      }\n    }\n    return fragment;\n  }\n}\n"]}