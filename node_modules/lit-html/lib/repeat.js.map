{"version":3,"file":"repeat.js","sourceRoot":"","sources":["../src/lib/repeat.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport {directive, DirectiveFn, NodePart} from '../lit-html.js';\n\nexport type KeyFn<T> = (item: T) => any;\nexport type ItemTemplate<T> = (item: T, index: number) => any;\n\ninterface State {\n  keyMap: Map<any, NodePart>;\n  parts: NodePart[];\n}\n\nconst stateCache = new WeakMap<NodePart, State>();\n\nexport function repeat<T>(\n    items: T[], keyFn: KeyFn<T>, template: ItemTemplate<T>): DirectiveFn;\nexport function repeat<T>(items: T[], template: ItemTemplate<T>): DirectiveFn;\nexport function repeat<T>(\n    items: Iterable<T>,\n    keyFnOrTemplate: KeyFn<T>| ItemTemplate<T>,\n    template?: ItemTemplate<T>): DirectiveFn {\n  let keyFn: KeyFn<T>;\n  if (arguments.length === 2) {\n    template = keyFnOrTemplate;\n  } else if (arguments.length === 3) {\n    keyFn = keyFnOrTemplate as KeyFn<T>;\n  }\n\n  return directive((part: NodePart): any => {\n\n    let state = stateCache.get(part);\n    if (state === undefined) {\n      state = {\n        keyMap: keyFn && new Map(),\n        parts: [],\n      };\n      stateCache.set(part, state);\n    }\n    const container = part.startNode.parentNode as HTMLElement | ShadowRoot |\n        DocumentFragment;\n    const oldParts = state.parts;\n    const endParts = new Map<Node, NodePart>(\n        oldParts.map((p) => [p.endNode, p] as [Node, NodePart]));\n    const keyMap = state.keyMap;\n\n    const itemParts = [];\n    let index = 0;\n    let currentMarker: Node|undefined;\n\n    for (const item of items) {\n      let result;\n      let key;\n      try {\n        result = template !(item, index++);\n        key = keyFn && keyFn(item);\n      } catch (e) {\n        console.error(e);\n        continue;\n      }\n\n      // Try to reuse a part, either keyed or from the list of previous parts\n      // if there's no keyMap\n      let itemPart = keyMap === undefined ? oldParts[0] : keyMap.get(key);\n\n      if (itemPart === undefined) {\n        // New part, attach it\n        if (currentMarker === undefined) {\n          currentMarker = new Text();\n          container.insertBefore(currentMarker, part.startNode.nextSibling);\n        }\n        const endNode = new Text();\n        container.insertBefore(endNode, currentMarker.nextSibling);\n        itemPart = new NodePart(part.instance, currentMarker, endNode);\n        if (key !== undefined && keyMap !== undefined) {\n          keyMap.set(key, itemPart!);\n        }\n      } else {\n        // Existing part, maybe move it\n        const range = document.createRange();\n        range.setStartBefore(itemPart.startNode);\n        range.setEndBefore(itemPart.endNode);\n\n        if (currentMarker === undefined) {\n          // this should be the first part, make sure it's first\n          if (part.startNode.nextSibling !== itemPart.startNode) {\n            // move the whole part\n            // get previous and next parts\n            const previousPart = endParts.get(itemPart.startNode);\n            if (previousPart) {\n              previousPart.endNode = itemPart.endNode;\n              endParts.set(previousPart.endNode, previousPart);\n            }\n            const contents = range.extractContents();\n            if (part.startNode.nextSibling === part.endNode) {\n              // The container part was empty, so we need a new endPart\n              itemPart.endNode = new Text();\n              container.insertBefore(\n                  itemPart.endNode, part.startNode.nextSibling);\n            } else {\n              // endNode should equal the startNode of the currently first part\n              itemPart.endNode = part.startNode.nextSibling!;\n            }\n            container.insertBefore(contents, part.startNode.nextSibling);\n          }\n          // else part is in the correct position already\n        } else if (currentMarker !== itemPart.startNode) {\n          // move to correct position\n          const previousPart = endParts.get(itemPart.startNode);\n          if (previousPart) {\n            previousPart.endNode = itemPart.endNode;\n            endParts.set(previousPart.endNode, previousPart);\n          }\n          const contents = range.extractContents();\n          container.insertBefore(contents, currentMarker);\n        }\n\n        // remove part from oldParts list so it's not cleaned up\n        oldParts.splice(oldParts.indexOf(itemPart), 1);\n      }\n      // else part is in the correct position already\n\n      itemPart.setValue(result);\n      itemParts.push(itemPart);\n      currentMarker = itemPart.endNode;\n    }\n\n    // Cleanup\n    if (oldParts.length > 0) {\n      const clearStart = oldParts[0].startNode;\n      const clearEnd = oldParts[oldParts.length - 1].endNode;\n      const clearRange = document.createRange();\n      if (itemParts.length === 0) {\n        clearRange.setStartBefore(clearStart);\n      } else {\n        clearRange.setStartAfter(clearStart);\n      }\n      clearRange.setEndAfter(clearEnd);\n      clearRange.deleteContents();\n      clearRange.detach();  // is this neccessary?\n    }\n\n    state.parts = itemParts;\n  });\n}\n"]}